
# ZoneMinder Viewer

**Almost all the code here was auto-generated by windsurf. I made very few changes manually (less than 5 lines of code).**

A Flutter-based application for viewing and managing ZoneMinder security camera feeds across multiple platforms. I've only tested with `macos`. I think there are still CORS issues to resolve for browsers in the one or two times I tried to run it in Chrome.

Overall, let me say this:
- Day 1: I found the experience very unproductive. I had started with a more detailed PRD that listed all the functionality I wanted and I was expecting it to generate code that worked. I just couldn't make progress with the many errors it kept generating/fixing/and re-generating.
- Day 2: (After I pivoted my approach), I found it to be something I can leverage with two habit changing lessons for me:
   - I have to be patient with it failing, repeatedly. It knows how to fix bugs, and when bugs are generated that are specific, it can fix them better. Just like a starter developer.
   - I have to instruct it with specific technical details where possible. If I give it a non or partial technical goal (example: "ensure the code is modular" vs "split the code into the following components:..."), more often than not, it will generate a mess. This means, I need to know my stuff and guide it when it flounders (and it flounders often)
   - Start small (just like I would if I coded myself)
- Day 3: Much better, I roughed in an events view in seconds, now that I know how to work with it. However, there were many prompting loops required to fix issues it continues to create.

- The jury is still out on quality. I just don't see these tools producing high quality code or well structured code. There are many examples of this. As one example, it decided to create a single `main.dart` file with all views. I had to specifically prompt it to separate views. It chose to create a singleton service for my API calls (good), but then proceeded to make copies of the service to fix bugs in views (bad) that resulted in inconsistent state across views. Its generated JWT authentication code was poorly written and did not handle refresh tokens. It also did not carry over the auth tokens to other URLs. Many other examples.

- It still continues to make large scale mistakes for simple asks. Sometimes it works well, sometimes it goes on a complete tangent, that I just have to ask it to undo. For example, even though I got events working in minutes, when I asked it fix one aspect of the events screen, it completely messed up my generic zoneminder API services to a point that monitors stopped working.

- **The most frustrating part was that it kept breaking reasonable code it wrote earlier while trying to fix a completely unrelated problem. This happened over and over again. Get ready to undo**. For example, I ask it to fix an event format, and our good friend went ahead and concluded my service API for retrieving monitors is broken and went about fixing (breaking it)

![](images/monitors.png?raw=true)
![](images/events.png?raw=true)

## More details about my experiences from this effort

* At home, and for my personal experiments/projects, I code using both copilot (agent mode + claude 3.5 and 3.7) and windsurf. For this experiment, I used its `base` model. Even with base, **Windsurf is better in my experiments, by a large margin when I compare it to co-pilot.**. Note: I later switched to `claude 3.7 thinking` - not sure I noticed a lot of difference. 

_(For those who want to know the details: these editors don't make chat history easy, but a big shout out to [Shottr](https://shottr.cc/) that allows scrolling image captures. You'll see two folders with several images. [failed run 1](https://github.com/pliablepixels/zoneminder_viewer/tree/main/images/chats/run1-failed) and [failed run 2](https://github.com/pliablepixels/zoneminder_viewer/tree/main/images/chats/run2-failed) are histories of my chat with options that did not work. In these, I started with more explicit requirements. [success run 3](https://github.com/pliablepixels/zoneminder_viewer/tree/main/images/chats/run-3-success-part) is a partial capture of me starting small and building up. A lot of fun happened after these screenshots, but you get the gist. If you click on the images and find them super tiny, please increase zoom factor by a lot so you can read.)_

At a high level:
* I spent 2 days trying two approaches. 
   * Approach 1 was to write a detailed PRD on how the app should function, including how to use the APIs, how to layout screens, functional and non functional requirements. The output _looked_ impressive, but it was a nightmare to actually make it work. Between fixing build dependencies,getting the API to work and trying to figure out how one change was breaking many other views,  it was a never ending loop of problems. Windsurf kept making changes that broke other things. It finally got to a point where windsurf asked me to remove and reinstall flutter and all related packages as the 'right fix'. I told it 'No, flutter works great on other projects' and it said 'Ah! That is very important information' and proceeded to list another set of things that I knew won't work. That is when I killed this approach. 

   * Approach 2: I then reverted my approach to actually take baby steps. This approach worked much better as I was able to guide it step by step. This is the prompt I eventually used that worked the best:

   ```
   Create a flutter application that will run in iOS, Android, Linux and macOS. I will give you more instructions later, but right now make sure the app has:
   a) A wizard view that lets a user enter a ZoneMinder URL and credentials (make sure the URL input is sanitized to add any missing components like scheme)
   b) A monitor view that will show all the cameras in a montage
   c) An events view that will show all camera events

   For now, mock the screens. Make sure the code is well documented and each view has its own file
   ```

   From then, I had to spend 3-4 hours to keep tweaking it via prompts and it finally worked. Given I am not a flutter developer, this approach helped me. If I were familiar with flutter, I might have been faster developing the app. I am not sure. 

* The process was both fun and frustrating. It was wonderful to see windsurf apply its agents and tools to create my directories, run code, analyze output and try to auto fix them. The flow was seamless - that is the power of agents and tools. That being said, when you look beyond the surface and stop being amazed at how it automates steps, you come to the conclusion this is like taking a very inexperienced developer with access to, say, stackoverflow through building an app. Windsurf would continously make confident changes that wouldn't work, then extract error logs and try to fix them. **That makes sense - the "reasoning" part of most of these tools is the most underdeveloped. They are good at taking a problem statement and trying to fix it. Therefore, the problem needs to occur for them to know how to fix it.** (This is also why it's fascinating to see it create bad code and self fix, which is a great thing to watch unfold, but eventually wastes a lot of time) This is unlike a seasoned developer who can implement reasoning and logic from the start. The entire experience was similar to starting to paste code from elsewhere and debugging our way towards fixing it for the most part.

* That being said, I was particularly **impressed by its problem solving skills when restricted to specific areas that don't have a dependency on other areas**. This project requires viewing MJPEG streams. As simple as that requirement is, it is hard to implement in flutter for the desktop (google for this problem). The gist of the problem is that MJPEG is a continuous stream of images, that never stops. Therefore, if you do an `http get`, it will never stop receiving data. If you choose to use a regular browser view and stick it with `<img src=` chances are when you navigate out of the view, the browser won't release the object and your server will still be background streaming. I had to hint it a bit to look at a modified http dart implementation that implemented HTTP FETCH and it figured out the existing `Image.Network` widget wouldn't work because it used an older http stack. It then updated the http stack to a version that uses `FETCH` and proceeded to implement its own MJPEG widget to overcome this issue. That impressed me. 

![](images/mjpegsolving.png?raw=true)

 However, it never was able to solve via a custom MJPEG class. I finally reverted to WkWebView to display the MJPEG stream and that worked. I don't know if this will cause memory issues later as I've not had good experiences with memory being released when you change views in a browser object.

The funny part was somewhere along the way, it suggested I replace streaming MJPEG with a single photo to make it work. Sneaky bot :-))

![](images/funny.png?raw=true)

* I faced a lot of timeouts from Windsurf `Deadline exceeded: Encountered retryable error from model provider: context deadline exceeded (Client.Timeout or context cancellation while reading body)` - that slowed things down but hopefully their paid plans are better with this.


# Key Takeaways

* Windsurf was **well ahead** of copilot agent mode and its integrated experience is more convenient
* **Writing detailed PRDs did not work for me**. It confused the agents way too much to get to a working system. It was great to start, but end result was a massive mess to actually get to a running app.
* **Starting small and incrementally building** the app worked much better
* **Being super specific helps**, but almost to a point that you have to be the guiding expert
* **Isolate what you want it to fix with minimal dependencies** - It operates least frustratingly when the problem it is solving doesn't have a lot of dependencies on other aspects of the app
* **Get used to it breaking code and fixing it iteratively** - The agents work better by creating problems and then trying to fix them (takes a lot of time though, but it eventuall gets there).Get used to seeing the agent produce poor code with confidence and break everything. Don't give up though - keep guiding it on errors (if it is not able to self detect - sometimes it can if the output is on a terminal, but if its UI app related, it won't know)
* **Know when to break the agent loop with human intervention**. Break up the problem statement into smaller chunks if the old request keeps producing problems (ask it to undo X steps). If you see the agent mess up over and over again and breaking up the problem doesn't help, just do it manually. At some point, you will need to own your time. And this is where I'll say, stay off what the industry calls _vibe coding_. Use prompts when you need, write code when you need.
* **Fact check code**:It is critical to assess what it generates. Just because it works doesn't mean it is right. Here is one of many examples:
   * It struggled to get the authentication code right. The app uses a common pattern - you use a login API and it  gets back access and refresh tokens. When I gave it instructions to use access and refersh tokens and auto refresh when it expires, it implemented this approach by trying an API - if the answer was a 401, then it would re-login. It completely ignored the expiry times that came with the tokens. It also did not carry over the auth tokens to other URLs. Many other mistakes, such as inventing a new endpoint to refresh a token, when the API page did not list such and endpoint.

![](images/monitors.png?raw=true)

* There is a solid place for these tools. They get you started reasonably well, but don't go overboard. You still need to be the "expert" and you still need to know when these tools go for a loop (not kidding)! 
* They are good at solving contained jobs. 
* They are _very_ _very_ far from being you
* I don't yet buy the notion that AI code is better quality. I'm not seeing it yet. I actually think they repeatedly produce lower quality code. But I do buy them saving you time, if you know how to use them (corollary: If you don't, you'll spend a lot of time generating truck loads of tech debt and wasting your time). Great options that it is reasonably good at are:
   * Document generation for code or design. Use it as a starting point.
   * Test case generation (unit tests, which are isolated)
   * Understanding the codebase (including getting to a part of the code that does something you are looking for)
   * Analyze debug logs (well, not always, but in general, it can help you understand what is going on)
* **Build reusable libraries whenever you can. Automated AI code is not a replacement for well structured libraries**: if reducing time to market for repeated tasks is why ytou are using AI. Sure you can use AI to generate those libraries, but everything I said above applies. Use it judiciously.

## Building the Project

To clone and build this project:

1. Install Flutter SDK from [flutter.dev](https://flutter.dev/docs/get-started/install)
2. Clone the repository:
   ```bash
   git clone https://github.com/pliablepixels/zoneminder_viewer.git
   cd zoneminder_viewer
   ```
3. Install dependencies:
   ```bash
   flutter pub get
   ```
4. Run the app:
   ```bash
   flutter run -d macos
   ```

The app will launch on your macOS system. You'll need to:
1. Enter your ZoneMinder server URL
2. Enter your credentials
3. The app will display your camera monitors in a grid view

PS: If you want to use windsurf, and use MacOS. Make sure you make it use bash and not zsh. If you do use zsh, especially with power10k, windsurf may not be able to detect your terminal exit status properly for commands.